/**
* generate RTInfo for precise garbage collector
*
* Copyright: Copyright Digital Mars 2012 - 2014.
* License:   <a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
* Authors:   Rainer Schuetze
*/
module gc.rtinfo;

///////////////////////////////////////////////////////////////////////

template RTInfoImpl(T)
{
    enum RTInfoImpl = RTInfoImpl1!(T);
}

template RTInfoImpl1(T)
{
    static if (is(T == RTInfoData)) // avoid recursion on RTInfoData
        enum RTInfoImpl1 = rtinfoNoPointers;
    else static if (!is(typeof(T.sizeof))) // skip struct/class declarations without body
        enum RTInfoImpl1 = rtinfoNoPointers;
    else
        immutable(RTInfoData*) RTInfoImpl1 = &RTInfoImpl2!T;
}

template RTInfoImpl2(T)
{
    static if (is(T D == U[], U))
        immutable(RTInfoData) RTInfoImpl2 = cast(immutable) RTInfoData(null, &gc_markArray);
    else
        immutable(RTInfoData) RTInfoImpl2 = cast(immutable) RTInfoData(__traits(getPointerBitmap, T), null);
}

alias RTInfoType = const(RTInfoData)*;

/**
* shortcuts for the precise GC, also generated by the compiler
* used instead of the actual pointer bitmap
*/
enum RTInfoType rtinfoNoPointers  = cast(RTInfoType) null;
enum RTInfoType rtinfoHasPointers = cast(RTInfoType) cast(RTInfoData*) cast(void*)1;

// callback into the GC to scan the memory range given a specific type (scan conservatively if null)
alias gcMark = void delegate(void* p, void* end, const(TypeInfo) ti) nothrow;

// callback from the GC to allow custom scanning of the memory range
extern(C) alias rtMark = void function(void* p, void* end, const(TypeInfo) ti, gcMark dg) nothrow;

// custom scanning for arrays
extern(C) void gc_markArray(void* p, void* end, const(TypeInfo) ti, gcMark dg) nothrow;

struct RTInfoData
{
    immutable(size_t)[] bmp;
    rtMark mark;
}

