/**
 * Written in the D programming language.
 * This module provides linux-specific support for sections.
 *
 * Copyright: Copyright Martin Nowak 2012-2013.
 * License:   <a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
 * Authors:   Martin Nowak
 * Source: $(DRUNTIMESRC src/rt/_sections_linux.d)
 */

module rt.sections_linux;

version (linux):

// debug = PRINTF;
import core.stdc.stdio;
import core.stdc.stdlib : calloc, malloc, free;
import core.stdc.string : strlen;
import core.sys.linux.elf;
import core.sys.linux.link;
import core.sys.posix.pthread;
import core.memory;
import rt.minfo;
import rt.deh_win64_posix;
import rt.util.container;

extern (C) void thread_joinAll();

alias DSO SectionGroup;
struct DSO
{
    static int opApply(scope int delegate(ref DSO) dg)
    {
        DsoMutex.lock();
        foreach(dso; _static_dsos)
        {
            if (auto res = dg(*dso))
            {
                DsoMutex.unlock();
                return res;
            }
        }
        DsoMutex.unlock();
        return 0;
    }

    static int opApplyReverse(scope int delegate(ref DSO) dg)
    {
        DsoMutex.lock();
        foreach_reverse(dso; _static_dsos)
        {
            if (auto res = dg(*dso))
            {
                DsoMutex.unlock();
                return res;
            }
        }
        DsoMutex.unlock();
        return 0;
    }

    @property inout(ModuleInfo*)[] modules() inout
    {
        return _moduleGroup.modules;
    }

    @property ref inout(ModuleGroup) moduleGroup() inout
    {
        return _moduleGroup;
    }

    @property immutable(FuncTable)[] ehTables() const
    {
        return _ehTables[];
    }

    @property inout(void[])[] gcRanges() inout
    {
        return _gcRanges[];
    }

private:

    invariant()
    {
        assert(_moduleGroup.modules.length);
        assert(_tlsMod || !_tlsSize);
    }

    immutable(FuncTable)[] _ehTables;
    ModuleGroup _moduleGroup;
    Array!(void[]) _gcRanges;
    size_t _tlsMod;
    size_t _tlsSize;
}

/****
 * Gets called on program startup just before GC is initialized.
 */
void initSections()
{
}


/***
 * Gets called on program shutdown just after GC is terminated.
 */
void finiSections()
{
}

/***
 * Called once per thread; returns array of thread local storage ranges
 */
Array!(void[])* initTLSRanges()
{
    DsoMutex.lock();
    _tlsRanges.length = _static_dsos.length;
    foreach (i, ref dso; _static_dsos)
        _tlsRanges[i] = getTLSRange(dso._tlsMod, dso._tlsSize);
    DsoMutex.unlock();
    return &_tlsRanges;
}

void finiTLSRanges(Array!(void[])* rngs)
{
    rngs.reset();
}

void scanTLSRanges(Array!(void[])* rngs, scope void delegate(void* pbeg, void* pend) dg)
{
    foreach (rng; *rngs)
        dg(rng.ptr, rng.ptr + rng.length);
}

private:

/*
 * Static DSOs loaded by the runtime linker. This includes the
 * executable. These can't be unloaded.
 * Should access to this be wrapped in a mutex? After all, what if one
 * thread is unloading a DLL while another is scanning exception tables?
 */
__gshared Array!(DSO*) _static_dsos;

Array!(void[]) _tlsRanges;

/* Mutex so we can load/unload DSO's from multiple threads
 */
struct DsoMutex
{
    __gshared pthread_mutex_t mutex;

    static void init()
    {
        pthread_mutex_init(&mutex, null);
    }

    static void term()
    {
        pthread_mutex_destroy(&mutex);
    }

    static void lock()
    {
        pthread_mutex_lock(&mutex);
    }

    static void unlock()
    {
        pthread_mutex_unlock(&mutex);
    }
}


///////////////////////////////////////////////////////////////////////////////
// Compiler to runtime interface.
///////////////////////////////////////////////////////////////////////////////


/*
 * This data structure is generated by the compiler, and then passed to
 * _d_dso_registry().
 */
struct CompilerDSOData
{
    size_t _version;                                  // currently 1
    void** _slot;                                     // can be used to store runtime data
    object.ModuleInfo** _minfo_beg, _minfo_end;       // array of modules in this object file
    immutable(rt.deh_win64_posix.FuncTable)* _deh_beg, _deh_end; // array of exception handling data
}

T[] toRange(T)(T* beg, T* end) { return beg[0 .. end - beg]; }

/* For each shared library and executable, the compiler generates code that sets
 * up CompilerDSOData and then calls _d_dso_registry().
 * A pointer to that code is then inserted into both the .ctors and .dtors
 * segment so it gets called by the loader on startup and shutdown.
 */
extern(C) void _d_dso_registry(CompilerDSOData* data)
{
    //printf("_d_dso_registry(%p)\n", data);

    // only one supported currently
    data._version >= 1 || assert(0, "corrupt DSO data version");

    // no backlink => register
    if (*data._slot is null)
    {
        DSO* pdso = cast(DSO*).calloc(1, DSO.sizeof);
        assert(typeid(DSO).init().ptr is null);
        *data._slot = pdso; // store backlink in library record

        pdso._moduleGroup = ModuleGroup(toRange(data._minfo_beg, data._minfo_end));
        pdso._ehTables = toRange(data._deh_beg, data._deh_end);

        dl_phdr_info info = void;
        findDSOInfoForAddr(data._slot, &info) || assert(0);

        scanSegments(info, pdso);

        checkModuleCollisions(info, pdso._moduleGroup.modules);

        /* If this is the first one, then it is the initialization of druntime and there's
         * only one thread, so no need to sync yet.
         */
        if (_static_dsos.length == 0)
            DsoMutex.init();

        DsoMutex.lock();
        _static_dsos.insertBack(pdso);
        DsoMutex.unlock();

        // Run module constructors for DSO
        pdso._moduleGroup.sortCtors();
        pdso._moduleGroup.runCtors();
        pdso._moduleGroup.runTlsCtors();
    }
    // has backlink => unregister
    else
    {
        DSO* pdso = cast(DSO*)*data._slot;

        // Run module destructors for DSO
        pdso._moduleGroup.runTlsDtors();
        if (pdso._moduleGroup.first)
            thread_joinAll();
        pdso._moduleGroup.runDtors();

        /* If DSOs come from dynamically loaded DLLs, they can be unloaded
         * in any order. Most of the time, however, they'll be unloaded in
         * reverse order. So search backwards for pdso in _static_dsos[].
         * Once we find it, ripple the trailing entries over it, and shorten
         * _static_dsos[] by one.
         */
        DsoMutex.lock();
        for (size_t i = _static_dsos.length; ; )
        {
            assert(i);                  // it must be there
            --i;
            if (pdso == _static_dsos[i])
            {   // Found it. Now ripple
                while (i + 1 < _static_dsos.length)
                {
                    _static_dsos[i] = _static_dsos[i + 1];
                }
                break;
            }
        }

        _static_dsos.popBack();         // shorten _static_dsos[]
        DsoMutex.unlock();

        *data._slot = null;

        if (pdso._moduleGroup.first)
            DsoMutex.term();            // last one, don't need mutex no more
        else
        {
            /* Tell the GC that it doesn't need to scan the (non-TLS) data
             * sections from this DSO anymore.
             */
            foreach (rng; pdso._gcRanges)
            {
                GC.removeRange(rng.ptr);
            }
        }

        pdso._gcRanges.reset();
        .free(pdso);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Elf program header iteration
///////////////////////////////////////////////////////////////////////////////

/************
 * Scan segments in Linux dl_phdr_info struct and store
 * the TLS and writeable data segments in *pdso.
 */
void scanSegments(in ref dl_phdr_info info, DSO* pdso)
{
    foreach (ref phdr; info.dlpi_phdr[0 .. info.dlpi_phnum])
    {
        // If loadable segment and writeable
        if (phdr.p_type == PT_LOAD && phdr.p_flags & PF_W)
        {
                                  /* base address + virtual address */
            auto beg = cast(void*)(info.dlpi_addr + phdr.p_vaddr);
            pdso._gcRanges.insertBack(beg[0 .. phdr.p_memsz]);
        }
        else if (phdr.p_type == PT_TLS)
        {   // Thread local storage segment
            assert(!pdso._tlsSize); // is unique per DSO
            pdso._tlsMod = info.dlpi_tls_modid;
            pdso._tlsSize = phdr.p_memsz;
        }
    }
}

/**************************
 * Input:
 *      result  where the output is to be written; dl_phdr_info is a Linux struct
 * Returns:
 *      true if found, and *result is filled in
 * References:
 *      http://linux.die.net/man/3/dl_iterate_phdr
 */
nothrow
bool findDSOInfoForAddr(in void* addr, dl_phdr_info* result=null)
{
    static struct DG { const(void)* addr; dl_phdr_info* result; }

    extern(C) nothrow
    int callback(dl_phdr_info* info, size_t sz, void* arg)
    {
        auto p = cast(DG*)arg;
        if (findSegmentForAddr(*info, p.addr))
        {
            if (p.result !is null) *p.result = *info;
            return 1; // break;
        }
        return 0; // continue iteration
    }

    auto dg = DG(addr, result);

    /* Linux function that walks through the list of an application's shared objects and
     * calls 'callback' once for each object, until either all shared objects
     * have been processed or 'callback' returns a nonzero value.
     */
    return dl_iterate_phdr(&callback, &dg) != 0;
}

/*********************************
 * Determine if 'addr' lies within shared object 'info'.
 * If so, return true and fill in 'result' with the corresponding ELF program header.
 */
nothrow
bool findSegmentForAddr(in ref dl_phdr_info info, in void* addr, ElfW!"Phdr"* result=null)
{
    if (addr < cast(void*)info.dlpi_addr) // less than base address of object means quick reject
        return false;

    foreach (ref phdr; info.dlpi_phdr[0 .. info.dlpi_phnum])
    {
        auto beg = cast(void*)(info.dlpi_addr + phdr.p_vaddr);
        if (cast(size_t)(addr - beg) < phdr.p_memsz)
        {
            if (result !is null) *result = phdr;
            return true;
        }
    }
    return false;
}

nothrow
const(char)[] dsoName(const char* dlpi_name)
{
    import core.sys.linux.errno;
    // the main executable doesn't have a name in its dlpi_name field
    const char* p = dlpi_name[0] != 0 ? dlpi_name : program_invocation_name;
    return p[0 .. strlen(p)];
}

nothrow
void checkModuleCollisions(in ref dl_phdr_info info, in ModuleInfo*[] modules)
in { assert(modules.length); }
body
{
    const(ModuleInfo)* conflicting;

    // find the segment that contains the ModuleInfos
    ElfW!"Phdr" phdr=void;
    if (!findSegmentForAddr(info, modules[0], &phdr))
    {
        // the first ModuleInfo* points into another DSO
        conflicting = modules[0];
    }
    else
    {
        // all other ModuleInfos must be in the same segment
        auto beg = cast(void*)(info.dlpi_addr + phdr.p_vaddr);
        foreach (m; modules[1 .. $])
        {
            auto addr = cast(const(void*))m;
            if (cast(size_t)(addr - beg) >= phdr.p_memsz)
            {
                conflicting = m;
                break;
            }
        }
    }

    if (conflicting !is null)
    {
        dl_phdr_info other=void;
        findDSOInfoForAddr(conflicting, &other) || assert(0);

        auto modname = (cast(ModuleInfo*)conflicting).name;
        auto loading = dsoName(info.dlpi_name);
        auto existing = dsoName(other.dlpi_name);
        fprintf(stderr, "Fatal Error while loading '%.*s':\n\tThe module '%.*s' is already defined in '%.*s'.\n",
                cast(int)loading.length, loading.ptr,
                cast(int)modname.length, modname.ptr,
                cast(int)existing.length, existing.ptr);
        assert(0);
    }
}

///////////////////////////////////////////////////////////////////////////////
// TLS module helper
///////////////////////////////////////////////////////////////////////////////


/*
 * Returns: the TLS memory range for a given module and the calling
 * thread or null if that module has no TLS.
 *
 * Note: This will cause the TLS memory to be eagerly allocated.
 */
struct tls_index
{
    size_t ti_module;
    size_t ti_offset;
}

extern(C) void* __tls_get_addr(tls_index* ti);

void[] getTLSRange(size_t mod, size_t sz)
{
    if (mod == 0)
        return null;

    // base offset
    auto ti = tls_index(mod, 0);
    return __tls_get_addr(&ti)[0 .. sz];
}
